/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface Output {
  value: Program
  cost: bigint
}
export declare function curryTreeHash(treeHash: Uint8Array, args: Array<Uint8Array>): Uint8Array
export interface Coin {
  parentCoinInfo: Uint8Array
  puzzleHash: Uint8Array
  amount: bigint
}
export declare function toCoinId(coin: Coin): Uint8Array
export interface CoinSpend {
  coin: Coin
  puzzleReveal: Uint8Array
  solution: Uint8Array
}
export interface Spend {
  puzzle: Program
  solution: Program
}
export interface LineageProof {
  parentParentCoinInfo: Uint8Array
  parentInnerPuzzleHash?: Uint8Array
  parentAmount: bigint
}
export interface Nft {
  coin: Coin
  lineageProof: LineageProof
  info: NftInfo
}
export interface NftInfo {
  launcherId: Uint8Array
  metadata: NftMetadata
  metadataUpdaterPuzzleHash: Uint8Array
  currentOwner?: Uint8Array
  royaltyPuzzleHash: Uint8Array
  royaltyTenThousandths: number
  p2PuzzleHash: Uint8Array
}
export interface NftMetadata {
  editionNumber: bigint
  editionTotal: bigint
  dataUris: Array<string>
  dataHash?: Uint8Array
  metadataUris: Array<string>
  metadataHash?: Uint8Array
  licenseUris: Array<string>
  licenseHash?: Uint8Array
}
export interface ParsedNft {
  info: NftInfo
  innerPuzzle: Program
}
export interface NftMint {
  metadata: NftMetadata
  p2PuzzleHash: Uint8Array
  royaltyPuzzleHash: Uint8Array
  royaltyTenThousandths: number
}
export interface MintedNfts {
  nfts: Array<Nft>
  coinSpends: Array<CoinSpend>
  parentConditions: Array<Program>
}
export interface Curry {
  program: Program
  args: Array<Program>
}
export interface P2Coin {
  coin: Coin
  puzzleHash: Uint8Array
  publicKey: Uint8Array
  secretKey: Uint8Array
}
export declare function compareBytes(a: Uint8Array, b: Uint8Array): boolean
export declare function sha256(bytes: Uint8Array): Uint8Array
export declare function fromHexRaw(hex: string): Uint8Array
export declare function fromHex(hex: string): Uint8Array
export declare function toHex(bytes: Uint8Array): string
export declare class ClvmAllocator {
  constructor()
  nil(): Program
  deserialize(value: Uint8Array): Program
  deserializeWithBackrefs(value: Uint8Array): Program
  treeHash(program: Program): Uint8Array
  run(puzzle: Program, solution: Program, maxCost: bigint, mempoolMode: boolean): Output
  curry(program: Program, args: Array<Program>): Program
  pair(first: Program, rest: Program): Program
  alloc(value: ClvmValue): Program
  delegatedSpendForConditions(conditions: Array<Program>): Spend
  spendP2Standard(syntheticKey: Uint8Array, delegatedSpend: Spend): Spend
  spendP2DelegatedSingleton(launcherId: Uint8Array, coinId: Uint8Array, singletonInnerPuzzleHash: Uint8Array, delegatedSpend: Spend): Spend
  mintNfts(parent_coin_id: Uint8Array, nft_mints: Array<NftMint>): MintedNfts
  parseNftInfo(puzzle: Program): ParsedNft | null
  parseUnspentNft(parentCoin: Coin, parentPuzzle: Program, parentSolution: Program, coin: Coin): Nft | null
  spendNft(nft: Nft, innerSpend: Spend): Array<CoinSpend>
  remark(value: Program): Program
  aggSigParent(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigPuzzle(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigAmount(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigPuzzleAmount(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigParentAmount(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigParentPuzzle(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigUnsafe(publicKey: Uint8Array, message: Uint8Array): Program
  aggSigMe(publicKey: Uint8Array, message: Uint8Array): Program
  createCoin(puzzleHash: Uint8Array, amount: bigint, memos: Array<Uint8Array>): Program
  reserveFee(fee: bigint): Program
  createCoinAnnouncement(message: Uint8Array): Program
  createPuzzleAnnouncement(message: Uint8Array): Program
  assertCoinAnnouncement(announcementId: Uint8Array): Program
  assertPuzzleAnnouncement(announcementId: Uint8Array): Program
  assertConcurrentSpend(coinId: Uint8Array): Program
  assertConcurrentPuzzle(puzzleHash: Uint8Array): Program
  assertSecondsRelative(seconds: bigint): Program
  assertSecondsAbsolute(seconds: bigint): Program
  assertHeightRelative(height: number): Program
  assertHeightAbsolute(height: number): Program
  assertBeforeSecondsRelative(seconds: bigint): Program
  assertBeforeSecondsAbsolute(seconds: bigint): Program
  assertBeforeHeightRelative(height: number): Program
  assertBeforeHeightAbsolute(height: number): Program
  assertMyCoinId(coinId: Uint8Array): Program
  assertMyParentId(parentId: Uint8Array): Program
  assertMyPuzzleHash(puzzleHash: Uint8Array): Program
  assertMyAmount(amount: bigint): Program
  assertMyBirthSeconds(seconds: bigint): Program
  assertMyBirthHeight(height: number): Program
  assertEphemeral(): Program
  sendMessage(mode: number, message: Uint8Array, data: Array<Program>): Program
  receiveMessage(mode: number, message: Uint8Array, data: Array<Program>): Program
  softfork(cost: bigint, value: Program): Program
}
export declare class Program {
  isAtom(): boolean
  isPair(): boolean
  treeHash(): Uint8Array
  serialize(): Uint8Array
  serializeWithBackrefs(): Uint8Array
  length(): number | null
  toAtom(): Uint8Array | null
  toPair(): [Program, Program] | null
  get first(): Program
  get rest(): Program
  toList(): Array<Program>
  uncurry(): Curry | null
  toString(): string | null
  toSmallNumber(): number | null
  toBigInt(): bigint | null
}
export declare class Simulator {
  constructor()
  newCoin(puzzleHash: Uint8Array, amount: bigint): Coin
  newP2(amount: bigint): P2Coin
  spend(coinSpends: Array<CoinSpend>, secretKeys: Array<Uint8Array>): void
}

/* auto-generated by `pnpm run update-declarations` */

export type ClvmValue = number | bigint | string | boolean | Program | Uint8Array | ClvmValue[];
